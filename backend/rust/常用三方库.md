# 常用三方库
## 1、cargo-watch
### 1.1、安装
地址： https://crates.io/crates/cargo-watch

```shell
cargo install cargo-watch
```

### 1.2、使用
```shell
cargo watch -q -c -w src -x run
```

### 1.3、查看帮助
```shell
cargo watch --help
```

## 2、tokio
### 2.1、安装
```js
[dependencies]
tokio = { version = "1.0", features = ["full"] }
```

### 2.2、使用
#### 2.2.1、简单示例
```js
```

## 3、hyper
:::tip
hyper是一个基于Rust语言的HTTP库, hyper-rustls是一个基于Rust语言的TLS库。
:::

### 3.1、官网
https://hyper.rs/guides/0.14/

### 3.2、安装
```js
[dependencies]
hyper = { version = "0.14", features = ["full"] }
hyper-rustls = "0.24.1"
tokio = { version = "1", features = ["full"] }
```

### 3.3、Server

https://github.com/hyperium/hyper/blob/0.14.x/examples

#### 3.3.1、简单示例
```js
use std::{net::SocketAddr, convert::Infallible};

use hyper::{service::{make_service_fn, service_fn}, Server, Request, Response, Body};

async fn hello_world(_req: Request<Body>) -> Result<Response<Body>, Infallible> {
    Ok::<Response<Body>, Infallible>(Response::new("Hello, World".into()))
}

#[tokio::main]
async fn main() {
    let addr = SocketAddr::from(([127, 0, 0, 1], 5000));
    
    let make_svc = make_service_fn(|_conn| async {
        Ok::<_, Infallible>(service_fn(hello_world))
    });
    // 创建服务
    let server = Server::bind(&addr).serve(make_svc);
    if let Err(e) = server.await {
        eprintln!("service error: {}", e);
    }
}
```

#### 3.3.2、https/http请求代理
Cargo.toml
```js
[dependencies]
hyper = {version = "0.14", features = ["full"]}
tokio = {version = "1", features = ["full"]}
hyper-rustls = "0.22"
futures-util = "0.3"
anyhow = "1.0.37"
```
main.rs
```js
use anyhow::*;
use std::sync::Arc;
use std::net::SocketAddr;
use hyper::{Body, Request, Server, Client};
use hyper::service::{make_service_fn, service_fn};
// hyper-rustls = "0.22" 版本过高不行

#[tokio::main]
async fn main() -> Result<()> {
    let https = hyper_rustls::HttpsConnector::with_native_roots();
    let client = Client::builder().build::<_, hyper::Body>(https);
    let client = Arc::new(client);

    let addr = SocketAddr::from(([0, 0, 0, 0], 7000));
    let make_svc = make_service_fn(move |_conn| {
        let client = Arc::clone(&client);
        async move {
            Ok(service_fn(
                move |mut req| {
                    let client = Arc::clone(&client);
                    async move {
                        println!("proxy: {}", req.uri().path());
                        proxy_crate(&mut req)?;
                        client.request(req).await.context("proxy request")
                    }
                }
            ))
        }
    });

    let _server = Server::bind(&addr).serve(make_svc).await.context("Run server");

    Ok(())
}

fn proxy_crate(req: &mut Request<Body>) -> Result<()> {
    for key in &["content-length", "accept-encoding", "content-encoding", "transfer-encoding"] {
        req.headers_mut().remove(*key);
    }
    let uri = req.uri();
    let uri_string = match uri.query() {
        Some(query_item) => format!("https://crates.io{}?{}", uri.path(), query_item),
        None => format!("https://crates.io{}", uri.path()),
    };
    *req.uri_mut() = uri_string.parse().context("Parsing URI Error")?;
    Ok(())
}
```

#### 3.3.3、api
```js
use anyhow::{Result, Error};
use futures_util::{future::ok, TryStreamExt};
use hyper::{service::{make_service_fn, service_fn}, Request, Body, Server, Response, StatusCode, body, Method};

#[tokio::main]
async fn main() -> Result<()> {
    let addr = "127.0.0.1:3000".parse().unwrap();
    let service = make_service_fn(|_| async {
        Ok::<_, Error>(service_fn(echo))
    });
    
    let server = Server::bind(&addr).serve(service);
    println!("Listening on http://{}", addr);
    
    server.await?;

    Ok(())
}

async fn echo(req: Request<Body>) -> Result<Response<Body>, Error> {
  match (req.method(), req.uri().path()) {
      (&Method::GET, "/") => Ok(Response::new(Body::from( "Try POSTing data to /echo such as: `curl localhost:3000/echo -XPOST -d 'hello world'`"))),
      (&Method::POST, "/echo") => {
          Ok(Response::new(req.into_body()))
      },
      (&Method::POST, "/echo/uppercase") => {
          let chunk_stream = req.into_body().map_ok(|chunk| {
              chunk.iter().map(|c| c.to_ascii_uppercase()).collect::<Vec<u8>>()
          });
          Ok(Response::new(Body::wrap_stream(chunk_stream)))
      },
      (&Method::POST, "/echo/reversed") => {
          let body = body::to_bytes(req.into_body()).await?;
          let reversed_body = body.iter().rev().cloned().collect::<Vec<u8>>();
          Ok(Response::new(Body::from(reversed_body)))
      },
      _ => {
          let mut not_found = Response::default();
          *not_found.status_mut() = StatusCode::NOT_FOUND;
          Ok(not_found)
      },
  }
}
```

#### 3.3.4、http代理
```js

use std::net::SocketAddr;

use anyhow::{Error, Result, Context, Ok};
use futures_util::TryStreamExt;
use hyper::{
    body,
    service::{make_service_fn, service_fn},
    Body, Client, Method, Request, Response, Server, StatusCode,
};

#[tokio::main]
async fn main() -> Result<()> {
    let addr: SocketAddr = "127.0.0.1:3000".parse()?;
    let out_addr: SocketAddr = "127.0.0.1:60244".parse()?;

    let client = Client::new();

    let service = make_service_fn(move |_| {
        let client = client.clone();
        let out_addr_clone = out_addr.clone();
        async move {
            Ok(service_fn(move |mut req| {
                let uri_string = format!(
                  "http://{}{}",
                  out_addr_clone,
                  req.uri()
                      .path_and_query()
                      .map(|x| x.as_str())
                      .unwrap_or("/")
                );
                let uri = uri_string.parse().unwrap();
                *req.uri_mut() = uri;
                client.request(req)
            }))
        }
    });

    let server = Server::bind(&addr).serve(service);
    println!("Listening on http://{}", addr);

    server.await?;

    Ok(())
}
```

### 3.4、Client
#### 3.4.1、简单示例
```js
use anyhow::*;
use hyper::Client;

#[tokio::main]
async fn main() -> Result<()> {
  let client = Client::new();
  let uri = "http://httpbin.org/ip".parse()?;

  let resp = client.get(uri).await?;
  println!("Response: {}--{:?}", resp.status(), resp.body());

  Ok(())
}
```

#### 3.4.2、打印body
```js
use anyhow::Result;
use hyper::{Client, body::HttpBody};
use tokio::io::{stdout, AsyncWriteExt as _};

#[tokio::main]
async fn main() -> Result<()> {
    let client = Client::new();
    let uri = "http://httpbin.org/ip".parse()?;
    let mut resp = client.get(uri).await?;
    println!("{}", resp.status());

    while let Some(chunk) = resp.body_mut().data().await {
        // println!("{:?}", chunk?);
        stdout().write_all(&chunk?).await?;
    }
    Ok(())
}
```
#### 3.4.3、post
```js
use anyhow::Result;
use hyper::{Client, Request, Body, Method};

#[tokio::main]
async fn main() -> Result<()> {
    let client = Client::new();

    let req = Request::builder()
        .method(Method::POST)
        .uri("http://httpbin.org/post")
        .header("content-type", "application/json")
        .body(Body::from(r#"{"key":"value"}"#))?;
      
    let resp = client.request(req).await?;
    // body -> Bytes
    let res = hyper::body::to_bytes(resp.into_body()).await?;
    // bytes -> String
    println!("body: {:?}", String::from_utf8_lossy(&res));
    Ok(())
}
```

#### 3.4.4、body to json
```js
use anyhow::Result;
use hyper::{Client, body::Buf};
use serde::Deserialize;

#[derive(Deserialize, Debug)]
struct User {
    id: i32,
    name: String,
}

#[tokio::main]
async fn main() -> Result<()> {
    let client = Client::new();
    let uri = "http://jsonplaceholder.typicode.com/users".parse()?;
    let res = client.get(uri).await?;
    let body = hyper::body::aggregate(res).await?;
    let users: Vec<User> = serde_json::from_reader(body.reader())?;

    for user in users {
        println!("id: {}, name: {}", user.id, user.name);
    }
     
    Ok(())
}
```

## 4、anyhow(异常捕捉)
### 4.1、安装
```js
[dependencies]
anyhow = "1.0.75"
```

### 4.2、使用
#### 4.2.1、Result
```js
use std::fs::File;
use anyhow::Result;

fn main() -> Result<()> {
    File::open("Cargo1.toml")?;
    Ok(())
}
```

#### 4.2.2、Context
```js
use anyhow::{Result, Context};
use hyper::Client;

#[tokio::main]
async fn main() -> Result<()> {
  let client = Client::new();
  let uri = "http1://httpbin.org/ip".parse()?;

  let resp = client.get(uri).await.context("context")?;
  println!("Response: {}--{:?}", resp.status(), resp.body());

  Ok(())
}
```

#### 4.2.3、with_context
```js
use std::fs;
use anyhow::{Result, Context};

fn main() -> Result<()> {
    let path = "Cargo1.toml";
    let content = fs::read(path)        
        .with_context(|| format!("Failed to read instrs from {}", path))?;
    println!("{:?}", content);
    Ok(())
}
```